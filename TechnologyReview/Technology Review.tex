%########################################
%CS 461 CAPSTONE 
%GROUP 20 - Griffin Gonsalves, Paul Kwak, Shawn Cross
%FALL 2016
%########################################
\documentclass[letterpaper, 10pt, draftclsnofoot, compsoc, onecolumn]{IEEEtran}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{supertabular}
\usepackage{hhline}

\usepackage{hyperref}
%\usepackage{digsig} %not a default package... just for signature field on final page.
\usepackage{comment}

\hypersetup{pdftex, colorlinks=true, linkcolor=black, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=SYSTEMS AND SOFTWARE REQUIREMENTS SPECIFICATION (SSRS) TEMPLATE, pdfauthor=Clinton Jeffery, pdfsubject=, pdfkeywords=}
\usepackage[pdftex]{graphicx}
% Outline numbering
\setcounter{secnumdepth}{3}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\arabic{section}.\arabic{subsection}}
\renewcommand\thesubsubsection{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}

\parindent0pt
\parskip 1.5ex plus 0.2ex minus 0.1ex
\makeatletter

\def\subsubsection{\@startsection{subsubsection}% name
                                 {3}% level
                                 {\z@}% indent (formerly \parindent)
                                 {1ex plus 0.1ex minus 0.1ex}% before skip
                                 {1ex}% after skip
                                 {\normalfont\normalsize}}% style

\newcommand\arraybslash{\let\\\@arraycr}
\makeatother
% Page layout (geometry)
\setlength\voffset{-1in}
\setlength\hoffset{-1in}
\setlength\topmargin{0.5in}
\setlength\oddsidemargin{.75in}
\setlength\evensidemargin{.75in}
\setlength\textheight{8.278in}
\setlength\textwidth{6.5in}
\setlength\footskip{0.561in}
\setlength\headheight{0.5in}
\setlength\headsep{0.461in}
% Footnote rule
\setlength{\skip\footins}{0.0469in}
\renewcommand\footnoterule{\vspace*{-0.0071in}\setlength\leftskip{0pt}\setlength\rightskip{0pt plus 1fil}\noindent\textcolor{black}{\rule{0.25\columnwidth}{0.0071in}}\vspace*{0.0398in}}
% Pages styles
\makeatletter
\newcommand\ps@Standard{
  \renewcommand\@oddhead{\hfill }
  \renewcommand\@evenhead{\@oddhead}
  \renewcommand\@oddfoot{\foreignlanguage{english}{\textcolor{black}{SSRS Page }}\foreignlanguage{english}{\textcolor{black}{\thepage{}}}}
  \renewcommand\@evenfoot{\@oddfoot}
  \renewcommand\thepage{\arabic{page}}
}
\newcommand\ps@FirstPage{
  \renewcommand\@oddhead{}
  \renewcommand\@evenhead{\@oddhead}
  \renewcommand\@oddfoot{}
  \renewcommand\@evenfoot{\@oddfoot}
  \renewcommand\thepage{\arabic{page}}
}
\makeatother
\pagestyle{Standard}
%\setlength\tabcolsep{1mm}
\renewcommand\arraystretch{1.3}
% footnotes configuration
\makeatletter
\renewcommand\thefootnote{\arabic{footnote}}
\makeatother
\title{Forge VR Explorer Requirements}
\author{Shawn Cross, Griffin Gonsalves, Paul Kwak}
\date{2016-11-3}



\begin{document}

\clearpage\setcounter{page}{1}\pagestyle{Standard}
\thispagestyle{FirstPage}

\bigskip

{\centering\selectlanguage{english}\bfseries\color{black}
Technology Review
\par}


\bigskip

{\centering\selectlanguage{english}\bfseries\color{black}
November 10 2016
\par}
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
%\begin{center}
%	\includegraphics[scale=0.8]{forge_logo.png}
%\end{center}


\vfill
{\centering\selectlanguage{english}\bfseries\color{black}
Abstract
\par}

{\centering\selectlanguage{english}\mdseries\color{black}
	The Forge VR Explorer branches from an Autodesk prototype project called Vrok-It, which is a simple web-based 3D 
	model viewer and mobile virtual reality (VR) explorer. The project will expand upon its ability to display uploaded 3D 
	models in browser and in VR, and improve its accessibility. Conventionally, viewing 3D models in VR is a challenge if 
	you have model files on many devices, or have a headset that only works in conjunction with a smart-phone. The 
	Forge VR Explorer aims to do this by utilizing a web-based software that uses the features of the Autodesk Forge API. 
	The project will also be expanded with new ideas and stretch goals as the project is developed.
\par}
\clearpage
{\centering\selectlanguage{english}\bfseries\color{black}
TABLE OF CONTENTS
\par}

\bigskip

\setcounter{tocdepth}{9}
\renewcommand\contentsname{}
\tableofcontents

\bigskip
\clearpage


\section{Introduction}
	The Forge VR team (group 20) will be working building on the Vrok-It project. We will be trying to make the site more accessible for users
	as well as trying to increase the performance of the  of the viewer and the VR experience too. Shawn Cross will be tasked with the file
	uploading feature, file conversion, and connecting the users device. Griffin Gonsalves will be working on the Website UI Redesign, Data Management API
	and Model Viewer. Paul Kwak is going to be working on Forge Authentication, Viewing in VR, and hardware detection.
	
\section{Technologies}

	\subsection{File Uploading}
		\begin{enumerate}
			\item{Options}
				\begin{itemize}
					\item  Use a plug-in: Using a plug-in that would handle file uploading would be very convenient as it takes a lot
						of the work out of it. One of the  biggest benefits would be that this could save us a lot of time. If we were to use
						the plug-in we would not have to worry about the effort that would normally go into creating our own, we could simply just
						find one that would fit  what we needed and the put it into our website. However this does also lead to the problem that we
						may not be able to find one that exactly fits what we want. Many of the plug-ins I have found so far simply upload the file to
						a server and then it is done. In our case we need the file to be usable by the website once it is uploaded.
 
					\item  Create our own file upload feature: Creating our own uploading feature would allow us to make the feature 
						work exactly the way that we would want to. Their a many different ways to do this though. One common way I have found 
						is to first create a web form using HTML to make the upload button.Then you could use PHP to submit the file through a POST.
						Using AJAX and JQuery you could also add features that show the progress of the upload and verification such as verifying correct 
						file types are being used. This could take a lot more time and effort to complete though depending on how skilled the person creating 
						the upload feature is and how fancy they want the feature to be.      

					\item  Create our own file uploading feature using new File API added to HTML5: This is similar to the previous option but seems like it might 
						be easier to learn and understand. Many of the features that we wanted are built into the API making it easier for us to create the 
						upload file file feature the way we want it. Though there will be some time for learning how to use the API and some time to completely
						create the feature, there is a lot of good documentation on this API that should make the process go smoothly.  
				\end{itemize}
			\item{Criteria being evaluated}
				\begin{enumerate}
					\item How much time will it take to integrate into our project: The plug-in will definitely take the least amount of time to add this to the project. I 
					think that the other two options will both take more time to do since you will have to create the upload feature from scratch.
					\item How much effort will have to go into learning how to complete the task: The plug-in won't take a lot of time to learn how to use since you just 
					need to add the library to the project and then you can use it. The other two options will take more time to learn how to do but shouldn't be to much 
					time since there is a lot of documentation and examples on-line showing how to do this. 
					\item Will the upload feature do exactly what you wanted it to do: If you aren't really particular about what the file upload button looks like or how it shows
					the progress of the upload then the plug-in would work just fine. However if you want to make the upload button look a certain way and show its progress a
					certain way then one of the other two options is going to be best. 
					\item Which option will offer the most secure way to upload the file: All three options offer the same amount of security. 
				\end{enumerate}
			\item{Discussion:} The plug-in option will definitely save the most time in terms of learning it and getting it to work in on the website, 
					however it will likely give you little in the way of customizing and making the file upload feature work exactly how you would want 
					it to. Both of the options to make you own file upload feature will result in a longer time to learn how to do this as well as a longer
					time to complete the task. This does allow you to make sure the the file upload will do exactly what you are wanting it to do. the 
					third option will is also using HTML5 this means that is will work in all the new browsers.
			\item{Select Option:}
					 I believe that the extra time that it takes to create our own custom file upload feature will outweigh the extra amount of time 
					that it will take to do this. I also think that the use of the file API is better since it is well documented, easy to find examples
					for, and has many of the features that we wanted built into it.
		\end{enumerate}
	\subsection{File conversion}
		\begin{enumerate}
			\item{Options}
				\begin{itemize}

					\item accusoft API: This is an API that allows users to convert their CAD files in to raster files such as SVG (scalable vector graphic) files that could 
						to view in the model viewer. This API does cost money and depending on how many conversions the user is planning on doing this option
						could turn out to be relatively expensive. There is a lot of documentation on how this API can be integrated into an application but it seems
						as though the integration process could be harder if you are not using a certain types of applications.

					\item  Forge Model derivative API: This API has the ability to take users CAD source file and convert them into OBJ and STL files. This API can also
						convert the files directly into SVF files the same type of file that the model viewer API we will be using on this project uses. This API would 
						also not cost us anything to use while we are working on the project since the company that created the API is the same company we will 
						be making the project for. There might be a little bit of a learning curve when it comes to integrating it into the website but the API has a 
						lot of tutorials and documentation on how to use the API in an application.  This API also uses a token based authentication system that
						provides security when converting the users files. 

					\item  cloudconvert API: This API gives you the ability to convert from CAD source files to a SVG file but it also give you the ability to convert the 
						other way was well. This API also has well documented instruction on how to integrate this API into an application. That would make it easier
						to learn and take less time to complete the task. This API would cost money to use depending on how much time is spent doing the conversions.
						this one also requires that a key be used when doing the to be created which make this more secure to do file conversions on since it will be able 
						to verify that it is an actual users trying to do conversions. 

				\end{itemize}
			\item{Criteria being evaluated}
				\begin{enumerate}
					\item How much time will it take to integrate into the project: All three of the projects will take about the same amount of time to integrate into the 
					project. I think that the first option might take longer since the documentation looked like it might be hard to understand and didn't seem as accessible 
					as the other two APIs. 
					\item How much effort will have to go into learning how to complete the task: I think each of these could take a good amount of effort to understand how
					to use and set up. Options two and three seem to have easier to understand documentation and have more example of how to use the API. 
					\item How secure is the file conversion: The first API didn't say whether or not that it had a way of making sure that the file conversions were secure.
					Options two and three both had some sort of way of authenticating the conversion. Option two used a token system and option three used a key system.
				\end{enumerate}

			\item{Discussion:} These three options all offer similar conversions. They all convert the CAD source files into a usable file for the model viewer. The Forge API will however 
				convert the file into an SVF file that can then be directly loaded into the viewer. This could save time and make it easier to complete the task. The Forge API is also 
				free for us to use during the duration of the project so that would also make a big difference as well. Finally the Forge API offers the most secure option when it comes
				to converting the users files since it  requires a token authentication to even do the conversion. This token is created as soon as the user visits the website and last for 
				the duration that the user is on the website. Also with lots of documentation as well as tutorials on how to integrate the API into our application I feel like this option will
				take the least amount of time to complete the task. 

			\item{Select Option:}
				I Think that we should use the Forge model derivative API since it seems the most straight forward on how to integrate it into our application. It won't cost us any money
				to use and has a more secure way of converting the users files. 
		\end{enumerate}
	\subsection{Connecting the users device}
		\begin{enumerate}
			\item{Options:}
				\begin{itemize}
					\item Use a QR code plug-in: jquery.qrcode.js is a jquery plug-in that generates a QR code which can be scanned by a user to using a QR scanning application on
					their device to connect their device to the current web session. Using this would be relatively easy since we would just need to add the library to our project. That
					means that there wouldn't be a lot of learning time involved in using this option.

					\item QRickit API: This API can dynamically generate QR codes to be used in a web/mobile application. The API is free to use for personal and small business 
					applications so there would be no cost for us to use it with our project. There is also documentation on how to setup and use the API so this would cut down 
					on the time that it take to learn how to integrate it into our project. 

					\item QR Code Generator: This is another API that will that will generate a QR code for the us. It can easily be embedded into the web page by putting the 
					source into an image tag. This API also allow for you to specify how big you want it and allows for different backgrounds to be used. The API also Has all
					the documentation that is needed to set up and use so the time to integrate this API into the project would be much.  
			\end{itemize}
			\item{Criteria being evaluated}
				\begin{enumerate}
					\item How much time will it take to integrate into the project: I think that all of the options can pretty easily be integrated into the project. all have 
					documentation that clearly describes how set-up and use them. Overall I would say that each of them are about the same when it comes to the 
					amount of time that it will take to integrate them into our project.  
					\item Will there be a lot of learning involved in using the option: I also feel like that since each of these options has documentation describing how to 
					use each that the learning involved in each is pretty minimal. 
					\item Will it connect the users device quickly: each of the should have about the same time to connect the device. The only reason that there would be a 
					slow down in connecting the users device is if they had a slow Internet connection or if there was a lot of traffic on the website itself. 
				\end{enumerate}
			\item{Discussion:} Overall I think that all the options are pretty close to one another. All three of the options are pretty straight forward in terms of integrating them
			into the project.  All three should also connect the users device quickly. The two API options add the ability to customize the QR code, but that really isn't needed for 
			our project since we just need the QR code to be there so the user can connect their device. 
			\item{Select Option:} I would say that the plug-in is the best way to go since we can integrate the library directly into our project and not have to worry about making 
			any calls to an outside API. 
		\end{enumerate}
	\subsection{Website UI Redesign}
		\begin{enumerate}
			\item{Options}
				\begin{itemize}
					\item{WordPress}
					WordPress is a high-level framework that can generate a simple view for a website. Wordpress has the advantage of using many pre-created templates in order to display a page. Wordpress is highly supported by many browsers, and could simplify the process of creating updates to the site. There is also the added benefit of a very pristine looking webpage without spending too much time developing it.
					\item{AngularJS}
					Redesigning the entire site does not require starting from the ground up. We can implement a javascript framework that would help us organize and manage the site. Angular JS would assist us in creating a better interface for the website without that much learning required. Our project is already using javascript to handle much of the project operations, but implementing a framework for the interface should not conflict with the rest of the project. Angular is completely free and has plenty of documentation available. There is also the newer edition named Angular 2, but due to the complexity, it may not be advisable to use.
					\item{ReactJS}
					React JS is another javascript framework that can generate different views for the page from a special source file. It simplifies javascript programming, in addition to generating simplified code for the project. React is also completely free, and has plenty of documentation and tutorials available online. Mobile browsers also are supported by React.
				\end{itemize}
			\item{Goals}
			Improve site layout and visual appeal
			\item{Criteria being evaluated}
				\begin{itemize}
					\item{Development time:  Each different option would potentially take different amounts of time to complete-potentially much longer than we have time for. Evaluating how long it will take to implement is a necessity.}
					\item{Presentation: This would be the look and style of the option. Specifically, whether it looks nice or not.}
					\item{Learning curve: Having to learn a new framework for web development could take weeks of time. This also factors into the development time.}
				\end{itemize}
			\item{Discussion}
			Each option provides the advantage of creating a nice interface, but each does so at a cost. Angular could take the longest to learn, and could also be difficult to implement. React has the advantage of creating nicer interfaces at little overhead. It certainly is the most different and could be a challenge to learn, but the resulting pages could bet a great choice for the project. Wordpress, though convenient, will not be able to keep up with our project, and would be challenging to continually update the layout with each change to the project during the development phase.
			
			\item{Select Option}
			In weighing the options, using ReactJS would be the best option for the project. Because the site already has a working page, we think it would benefit the project more to spend less time developing the updated UI and more time on the focus of our project. After learning the basics, ReactJS should provide a great interface for our website that improves our development process.
		\end{enumerate}
	\subsection{Data Management API}
		\begin{enumerate}
			\item{Option}
				\begin{itemize}
					\item{Forge Data Management API: Belonging to the Forge collection of APIs created by Autodesk, this software allows for the user to pull project files from an Autodesk A360 library that contains a user's project files. These files could be filtered and shown in a user interface, which is a criteria for this technology. Once a website is registered with the API, and a user is logged in, files may be accessed in the interface.  The usage of the API is straightforward, after setup with the API, we would only need to include a provided configuration and setup on the site which could assist in rapidly developing this feature.}
					
					\item{OneDrive API: Another common cloud service is Microsoft's OneDrive. Microsoft provides a File Picker API through their Javascript SDK, which is also the main scripting language used in our project. After registering the app with Microsoft's API, one may implement a "Open from OneDrive" button which opens a File Picking window where the user may pick a file from their drive. This API would support all major web browsers, in addition to the most current mobile browsers. This API should have no problem integrating with our other assets, and provides a UI popup for selecting the file.}

					\item{Google Drive API: A similar, but more general use case API that fits the bill is the Google Drive API. This API lets a user log into their google account and access their files stored on Google Drive. Google claims the API works flawlessly in a straightforward HTML web document, so compatibility should not be an issue with other components in the project. Furthermore, since the API supports the viewing and interaction with user's files in an interface, the API meets the criteria of having an interface. This interface, called the Google Picker, functions as the interface for picking the file.}
					
					
				\end{itemize}
			\item{Goals}
			To provide an alternate method of file upload to the project through a cloud service.
			
			\item{Criteria being evaluated}
			\begin{itemize}
					\item{Level of browser/device support: How many modern browsers does the technology support?}
					\item{Project asset/Website compatibility: Does the new API work with the rest of the website?}
					\item{File picking user interface: Does the API's user-interface function for our project?}
				\end{itemize}
			\item{Discussion:}
			This sounds like a cut and dry choice for the Forge API, as we are already using Autodesk APIs and libraries on the site in addition to other Forge components. Using this API could save development time as the app need only be registered with the Forge service once, and appears relatively trivial to implement in the site. The Microsoft API seems useful, but the OneDrive cloud service is not oriented to provide large files on demand, and configuration seems much more complex. On the other hand, the Google Drive API seems like it could be a suitable backup. The functionality seems slightly more complex, however this would provide cloud access for users on the most used cloud platform.
			\item{Select Option:}
			Due to the inertia behind our project using the Forge Collection, I think the best option for the project is to include the Forge Data Management API. It meets each of the criteria for the project and should function as a useful feature when completed. 
		\end{enumerate}
		
	\subsection{Model Viewer}
		\begin{enumerate}
			\item{Option}
				\begin{itemize}
					\item{Forge Large Model Viewer: This is the current system in place for the project. Created by Autodesk, the LMV allows for larger project files to be viewed and manipulated in-browser, and on mobile for most modern smartphones. The viewer is placed in the web document as a window.}
					\item{WebVR Rendering: A very new initiative from Mozilla that provides high performance graphics on the web aimed at supporting many new VR devices, including Google Cardboard. The system supports different mobile devices and is also supported on mobile web browsers. The software is implemented within the project as a library. }
					\item{Unity 3D: Unity provides another method of 3D model viewing for browsers. The Unity Web Player is capable of detailed 3D projects in a web browser, including full 3D games, models, and more. Unity has also recently provided support for the Oculus Rift. However, the software is built upon the same OpenGL renderer as both WebVR and the LMV. }
		
				\end{itemize}
			\item{Goals}
			Provide a viewing interface in which to view a 3D model in-browser.
			
			\item{Criteria being evaluated:}
			
			\begin{itemize}
					\item{Model Quality:}
					\item{Web Viewing Experience}
					\item{VR Viewing Experience}
					\item{Device and VR system support}
			\end{itemize}
			
			\item{Discussion:}
			There is a large project codebase that was built on top of the Large Model Viewer specifically for the project. Moving to a different 3D/VR framework would take considerable work and commitment for the project as a whole, but could potentially bring more support and features to the project that we could use. WebVR by far seems the most advanced, high-quality and broad ranging in terms of device and browser support, but with the disadvantage of having nearly no documentation or tutorials. Unity provides a very easy to use web model viewer, but only has support for a single VR headset, which would fail to meet the Device and VR system support criteria. 
			\item{Select Option:}
			Currently the best option for our project at the moment would be the Large Model Viewer. Granted that both webVR and Unity support high quality models that can be inpsected closely, the amount of the project that currently relies on the LMV would be too large of a task to make the jump to a newer framework at this point given the alternatives. Through communication with our sponsor, we may be able to use a different framework later down the line, as there could be a new API to use. Currently, it does not seem sufficiently justified 
	\end{enumerate}
		
	\subsection{Forge Authentication}
		\begin{enumerate}
			\item{Option}
				\begin{itemize}
					\item OAuth2 is the open standard used in the Forge platform for token-based authentication and authorization. The basic flow for using OAuth commonly begins with an application making an HTTP call to a OAuth REST endpoint and providing its credentials. A token is returned to the application and then subsequent HTTP calls to various APIs on the platform include the token in the request header.
					\begin{itemize}
						\item Two-legged authentication: The default and simplest type of authentication. Should be used when an application makes a call to an API that utilizes resources that do not require the user's permission. The only interaction is between the application and the Forge platform. The user does not need to know about the authentication or provide authorization to the application for resource access.
						\item Three-legged authentication: Used for when an application requires access to resources belonging to an end user, and so that user must provide explicit authorization. For a web application, this will automatically redirect to an Autodesk login page and ask for the user's consent. Then the user is redirected to the application, which is now capable to accessing those resources
					\end{itemize}
				\end{itemize}
			\item{Goals} provides security to data interactions and also to resources that belong to users being exchanged.
			\item{Criteria being evaluated}
				\begin{itemize}
					\item{Whether users will need access to Forge resources}
					\item{Usability, users have to login and have an Autodesk account}
				\end{itemize}
			\item{Discussion} There is a slight possibility to be using both. Two-legged for simple users and then three-legged for users with Autodesk accounts. Regardless of whether we accommodate simple users, we definitely will have to use three-legged. This is due to the use of the Forge Data Management API, users who store their files will be using the Forge platform. Thus will have to have users verify our application the permissions to access their files. As for the use of two-legged that will vary depending on what other pieces are added.
			\item{Select Option} : The functionality of the Forge Data Management API revolves around users files so we will definitely have to utilize three-legged.
		\end{enumerate}

	\subsection{Viewing in VR}
		\begin{enumerate}
			\item{Option}
				\begin{itemize}
					\item
					Google Cardboard: Costs \$15. Turns any mobile device into a 3 dimensional viewing environment. Putting the phone into the contraption and using compatible apps allows a VR viewing experience. When porting in model files via QR code the issue is getting the files into format that makes them VR. There are a number of applications available for free that do this so the process might be very simple and definitely already exists.
					\item
					Costs \$599. A mobile VR viewer already exists that has CAD file viewing. However, costs money to use and is still a work in progress. Porting Solidworks CAD files directly into Unity is possible and works but does not utilize the flow we are using. Another avenue with might be to use an application under the sketchfab VR umbrella.
					\item	
					Costs \$1,500. Requires a PC to either view on, but also requires the user's phone to have bluetooth if the user wishes to use the phone. With this option also changes the flow for the project. CAD files can be exported from Solidworks into a .3DS format. The .3DS format can be directly imported into Unity which then has Vive support and allows for viewing via that. 
				\end{itemize}
			\item{Goals} display our adjusted model in VR while maintaining the smoothest possible viewing experience.
			\item{Criteria being evaluated}
				\begin{itemize}
					\item
					Cost/Accessibility
					\item	
					Documentation for each
					\item	
					How well does it fit within our established system.					
				\end{itemize}
			\item{Discussion}: Google Cardboard has several advantages. First off it's incredibly cheap price, will allow for greater accessibility. Especially for developers, each us will be able to use our own and testing models should be easy. Second is the high number of application that display models and their easy access (free). This gives us an easy way to compare our work, framerate wise. Finally since our current setup utilizes Vrot.it and already had a QR scanner to port the models to our phones. It becomes a matter of adjusting the model and then using the VR format Cardboard uses to get our desired VR model. Oculus and Vive come with the advantage of having higher hardware to work with. Our need to detect hardware becomes less of an issue since both work with PC's and then display to the phone via other methods. This comes at their high cost and additionally the applications out for those options don't utilize our current setup. In fact would change our setup completely since they alleviate the need to even upload files and just change our problem to converting CAD files to work with Unity. 
			\item{Select Option}: Google Cardboard is significantly cheaper and perfectly fits within the way we have setup in order to utilize what we have. 
		\end{enumerate}
	\subsection{Technology 9}
		\begin{enumerate}
			\item{Option}
			\item{Goals}
			\item{Criteria being evaluated}
			\item{Discussion}
			\item{Select Option}
		\end{enumerate}


\section{Conclusion}
After our technology review, we have made some important evaluations on our project and its different components. For many components, we decided it was best if we continued using some of the technologies from the original project, in addition to focusing on utilizing new API's and frameworks that fit the goals of our project. We are planning on potentially adding an updated version of the Forge Large Model Viewer that is currently being developed.

\bibliographystyle{IEEETran}
%\bibliography{bibfile}
\end{document}
